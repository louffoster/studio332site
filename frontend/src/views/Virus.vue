<template>
   <div id="game">
   </div>
</template>

<script setup>
import GameState from "@/games/virus/gamestate"
import Letter from "@/games/virus/letter"
import EnterKey from "@/games/virus/enterkey"
import ShuffleKey from "@/games/virus/shufflekey"
import DeleteKey from "@/games/virus/deletekey"
import StartOverlay from "@/games/virus/startoverlay"
import EndOverlay from "@/games/virus/endoverlay"
import WinOverlay from "@/games/virus/winoverlay"
import Gauge from "@/games/virus/gauge"
import Pool from "@/games/virus/pool"
import * as PIXI from "pixi.js"
import { onMounted, onBeforeUnmount } from "vue"
import axios from 'axios'
import * as particles from '@pixi/particle-emitter'
import { useGamesStore } from '@/stores/games'

import explode from '@/assets/explode.json'
import explode2 from '@/assets/explode2.json'
import { useRouter } from 'vue-router'

const API_SERVICE = import.meta.env.VITE_S332_SERVICE

const gameStore = useGamesStore()
const router = useRouter()

var gameElement = null

const ROWS = 6
const COLS = 5
const GAME_WIDTH = 300
const GAME_HEIGHT = 615
const MAX_INFECTIONS = 10//8

var app = null
var scene = null
var gfx = null
var virusExplode = null
var loseExplode = null

var grid = null
var pool = new Pool()
var initGameOverlay = null
var gameOverOverlay = null
var winOverlay = null
var state = new GameState()
var checkCountdown = 0
var addCountdown = 1000
var lastIncreasedTimeSec = 0
var infectionLevel = 3     // minmum number of infected tiles
var pendingInfections = 0  // numner of infections to add to bring up to current level
var gameTime = 0.0
var timerDisplay = null
var letterIndex = 0
var word = []
var lastWordSize = 0
var wordCounts = []
var gauges = []
var enterKey = null 
var shuffleKey = null
var deleteKey = null
var gameplayToken = ""

const initPixiJS = (() => {
   gameStore.currentGame = "virus"
   PIXI.settings.RESOLUTION = window.devicePixelRatio || 1
   app = new PIXI.Application({
      autoDensity: true, // Handles high DPI screens
      antialias: true,
      backgroundColor: 0x44444a,
      width: GAME_WIDTH,
      height: GAME_HEIGHT,
   })

   if (window.innerWidth <= GAME_WIDTH || window.innerHeight <= GAME_HEIGHT   ) {
      gameStore.fullScreen = true
      gameElement = document.body
      gameElement.appendChild(app.view)
      scene = new PIXI.Container()
      app.stage.addChild(scene)
      resize()
   } else {
      gameStore.fullScreen = false
      gameElement = document.getElementById("game")
      gameElement.appendChild(app.view)
      scene = new PIXI.Container()
      app.stage.addChild(scene)
   }
})

const resize = (() => {
    // Determine which screen dimension is most constrained
    let ratioW = window.innerWidth / GAME_WIDTH
    let ratioH = window.innerHeight / GAME_HEIGHT
    if ( window.innerWidth <  GAME_WIDTH ) {
      scene.scale.x = scene.scale.y = ratioW 
    } else {
      if ( window.innerHeight <  GAME_HEIGHT ) {
         scene.scale.x = scene.scale.y = ratioH
      }
      scene.position.x = ((window.innerWidth - GAME_WIDTH) / 2.0) / ratioW
    }

   app.renderer.resize( window.innerWidth, window.innerHeight)
})

onMounted(async () => {
   initPixiJS()

   // update partticle effect generated by UI to current version
   virusExplode = particles.upgradeConfig(explode, ['spark.png'])
   loseExplode = particles.upgradeConfig(explode2, ['spark.png'])

   layoutGameScreen()

   initGameOverlay = new StartOverlay(API_SERVICE) 
   gameOverOverlay = new EndOverlay(restartHandler, backHandler) 
   winOverlay = new WinOverlay(restartHandler) 
   scene.addChild(initGameOverlay)
   initGameOverlay.startGameInit( startGame )
})

const layoutGameScreen =(() => {
   gfx = new PIXI.Graphics() 
   scene.addChild(gfx)

   let y = 40
   let x = 40   
   grid = Array(ROWS).fill().map(() => Array(COLS))
   for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
         let l = new Letter("", x,y, r,c)
         l.setClickCallback(letterClicked)
         scene.addChild(l)
         grid[r][c] = l
         x += 55
      }
      y += 55
      x = 40
   } 

   let style = new PIXI.TextStyle({
      fill: "#cccccc",
      fontFamily: "\"Courier New\", Courier, monospace",
      fontSize: 24,
   })

   gfx.lineStyle(1, 0x888899, 1)
   gfx.moveTo(0, 352)
   gfx.lineTo(GAME_WIDTH, 352)
   gfx.moveTo(0, 413)
   gfx.lineTo(GAME_WIDTH, 413)

   // setup blank word... to be filled with clicked letters from grid
   x = 10
   for ( let i=0; i<6; i++) {
      // draw the underline for the lettercl
      gfx.moveTo(x, 395)
      gfx.lineTo(x+20, 395)  

      let wordLetter = new PIXI.Text("", style)
      wordLetter.x = x+2
      wordLetter.y = 365
      scene.addChild(wordLetter)
      word.push( {letter: wordLetter, fromRow: -1, fromCol: -1})

      x+=25
   }

   enterKey = new EnterKey(170,365, enterWord)
   scene.addChild(enterKey)
   deleteKey = new DeleteKey(170+70 ,365, backspaceClicked)
   scene.addChild(deleteKey)
   shuffleKey = new ShuffleKey(8,560, shuffleGrid)
   scene.addChild(shuffleKey)

   // word count gauges
   gauges = []
   let maxValues = [7,6,5,4] 
   let gaugeY = 430
   for (let i=0; i<4; i++) {
      let g = new Gauge(10,gaugeY,`${i+3}`, maxValues[i])
      gauges.push( g )
      scene.addChild( g )
      gaugeY+=28
   }

   // timer 
   gfx.moveTo(0, 550)
   gfx.lineTo(GAME_WIDTH, 550)
   timerDisplay = new PIXI.Text("00:00", {
      fill: "#44cc44",
      fontFamily: "\"Courier New\", Courier, monospace",
      fontSize: 18,
   })
   // timerDisplay.anchor.set(0.5,0)
   timerDisplay.x = 200
   timerDisplay.y = 565
   scene.addChild(timerDisplay)
})

const startGame = (( jwt ) => {
   gameplayToken = jwt
   console.log("TOKEN: " + gameplayToken)
   scene.removeChild(initGameOverlay)

   pool.refill()
   wordCounts = [0,0,0,0] // one for each letter count; 3,4,5,6

   for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
         grid[r][c].reset( pool.pop() )
      }
   } 

   state.initialized()
   app.start()
   app.ticker.add( gameLoop )
})

const checkInfectedCount = (() => {
   checkCountdown = 1000.0
   let cnt = 0
   for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
         // selected tiles don't expand the virus, so they don't count 
         if ( grid[r][c].isInfected() &&  grid[r][c].selected == false) {
            cnt++
         }
      }
   }

   // If there is nothing, always start fill in the 4 corners
   if ( cnt < 4){
      let tgtR = [0, 0, ROWS-1, ROWS-1]
      let tgtC = [0, COLS-1, 0, COLS-1]
      for ( let i = 0; i<4; i++) {
         if ( grid[ tgtR[i] ][ tgtC[i] ].isInfected() == false ) {
            grid[ tgtR[i] ][ tgtC[i] ].infect()
            cnt++
            if (cnt == 4) {
               break
            }
         }  
      }
   }

   // keep the number of infected tiles at a minum of the current level
   if ( cnt < infectionLevel) {
      pendingInfections = infectionLevel - cnt
      addCountdown = 1000
   } else {
      pendingInfections = 0
      addCountdown = 0
   }
})

const addInfectedTile = (() => {
   let added = false
   for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
         if (grid[r][c].infected == false) {
            grid[r][c].infect()
            added  = true
            break 
         }
      }
      if (added ) break
   }
})

const shuffleGrid =(() => {
   if (state.isPlaying() == false) return 
   
   clearWord()
   let newLetters = pickNewLetters(ROWS*COLS) 
   for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
         grid[r][c].replace( newLetters.pop() )  
      }
   }
})

const enterWord = (() => {
   if (state.isPlaying() == false) return 
   
   state.requestSubmit()
   setWordColor(0xaaddff)  
})

const doSubmission = ( async () => {
   // 3 letters or more required!
   if ( letterIndex < 3) {
      addInfectedTile()
      failedWord()
      return
   }

   let testWord = ""
   word.forEach( l => testWord += l.letter.text)
   let url = `${API_SERVICE}/virus/check?w=${testWord}`
   await axios.post(url).then( () => {
      wordAccepted( )
      enterKey.wordSubmitted()
   }).catch( _e => {
      failedWord()
      addInfectedTile()
      enterKey.wordSubmitted()
   })
})

const failedWord = (() => {
   setWordColor(0xff5555)
   state.submitFailed()
})

const setWordColor = (( c ) => {
   word.forEach( wl => {
      wl.letter.style.fill = c
   }) 
})

const wordAccepted = (() => {
   // letter index is the index of the next letter to add, so it is the word length
   lastWordSize = letterIndex 
   state.submitSuccess( lastWordSize )
})

const disinfectLetter = (() =>{
   // clear the letter from the word and deselect it from the grid
   let selR = word[letterIndex].fromRow
   let selC = word[letterIndex].fromCol 
   let isSelectedInfected = grid[selR][selC].infected

   // reset grid letter and clear word letter
   grid[selR][selC].reset( pickNewLetter() )   
   word[letterIndex].letter.text = ""
   word[letterIndex].fromCol = -1
   word[letterIndex].fromRow = -1  

   // If this letter was infected, nothing left to do
   if ( isSelectedInfected ) {
      startVirusExplode( selR, selC)
      return
   } 

   // go from bottom right to top left and clear one infected or lost tile
   // start with restoring lost tiles. when there are none, reset infected
   let done = false
   let pass = 0
   while ( done == false && pass < 2) {
      if ( letterIndex % 2) {
         for (let r = (ROWS-1); r >= 0; r--) {
            for (let c = (COLS-1); c  >= 0; c--) {
               if ( (pass == 0 && grid[r][c].isLost()) || 
                    (pass == 1 && grid[r][c].infected) )  {       
                  grid[r][c].reset( pickNewLetter() )
                  done = true
                  startVirusExplode( r, c )
                  break
               }
            }
            if (done) {
               break
            }
         }
      } else {
         for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c  < COLS; c++) {
               if ( (pass == 0 && grid[r][c].isLost()) || 
                    (pass == 1 && grid[r][c].infected) )  {       
                  grid[r][c].reset( pickNewLetter() )
                  done = true
                  startVirusExplode( r, c )
                  break
               }
            }
            if (done) {
               break
            }
         }
      }
      pass++
   }
})

const clearWord = (() => {
   word.forEach( wl  => {
      if (wl.letter.text != "") {
         grid[wl.fromRow][wl.fromCol].deselect()
         wl.letter.text = ""
         wl.fromCol = -1
         wl.fromRow = -1   
      }
   })
   letterIndex = 0
   lastWordSize = 0
   Letter.wordFull = false
   enterKey.setEnabled(false)
   deleteKey.setEnabled(false)
})

const pickNewLetter = (() => {
   let l = pickNewLetters(1)
   return l[0]
})

const pickNewLetters = (( cnt ) => {
   let out = [] 
   for (let i=0; i<cnt; i++ ) {
      if ( pool.hasTilesLeft() == false) {
         pool.refill()
      }
      out.push( pool.pop() )
   }
   return out
})

const backspaceClicked = (() => {
   if (letterIndex > 0) {
      letterIndex--  
      let c = word[letterIndex].fromCol
      let r = word[letterIndex].fromRow
      grid[r][c].deselect() 
      word[letterIndex].letter.text = ""
      word[letterIndex].fromCol = -1
      word[letterIndex].fromRow = -1
   }
   letterIndex = Math.max(letterIndex, 0)
   enterKey.setEnabled( letterIndex > 2 )
   deleteKey.setEnabled( letterIndex > 0 )
})

const letterClicked = (( row, col, letter) => {
   if (state.isGameOver()) return 

   Letter.wordFull = false
   word[letterIndex].letter.text = letter
   word[letterIndex].fromCol = col
   word[letterIndex].fromRow = row 
   letterIndex++ 
   if ( letterIndex > 2) {
      enterKey.setEnabled(true)
   }
   if (letterIndex == 6) {
      Letter.wordFull = true
   }
   deleteKey.setEnabled( true )
})

const startVirusExplode = ((row, col) => {
   var emitter = new particles.Emitter(scene, virusExplode )

   // start of grid is 40,40 each letter is 55x55
   let x = 40 + (col*55)
   let y = 40 + (row*55)
   emitter.updateOwnerPos(0,0)
   emitter.updateSpawnPos(x,y)
   emitter.playOnceAndDestroy()
})

const beginGameOver = (() => {
   state.gameLost()

   // wipe out any started word and take over all remaining letters
   clearWord()
   for (let r = (ROWS-1); r >= 0; r--) {
      for (let c = (COLS-1); c  >= 0; c--) {
         grid[r][c].fullyInfect()
      }
   }

   // blow up submit and shuffle
   startLossExplode( 200,385 )
   startLossExplode( 260,385 )

   // blow up all gauges
   let y = 430
   let x = 45
   for (let i=0; i<=4; i++) {
      for (let j=0; j<=4; j++) {
         startLossExplode( x,y )
         x+= 55
      }
      x= 45
      y+=26
   }

   setTimeout( () => {
      gauges.forEach( g => {
         g.reset() 
      })
      scene.removeChild(enterKey)
      scene.removeChild(shuffleKey)
      scene.removeChild(deleteKey)
   }, 500)
})

const startLossExplode = ( (x,y) => {
   var emitter = new particles.Emitter(scene, loseExplode )
   emitter.updateOwnerPos(0,0)
   emitter.updateSpawnPos(x,y)
   emitter.playOnceAndDestroy()
})

const letterLost = (( row, col ) => {
   if ( state.isGameOver()) return

   let biggestWordLeft = 0 
   let sizes = [3,4,5,6]
   gauges.forEach( (g, idx) =>{
      if (g.isFull() == false) {
         biggestWordLeft = sizes[idx]   
      }
   })

   let remainingLetters = 0
   for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
         if ( grid[r][c].isLost() == false) {
            remainingLetters++
         }
      }
   }
   
   // console.log("Letters left: "+remainingLetters+", biggestWordLeft: "+biggestWordLeft)
   if ( remainingLetters < biggestWordLeft ) {
      beginGameOver()
      return
   }

   let isInWord = false 
   word.forEach( wl => {
      if (wl.fromRow == row && wl.fromCol == col) {
         isInWord = true
      }
   })
   if ( isInWord ) {
      clearWord()
   }

   if ( row > 0) {
      grid[row-1][col].infect()
   }
   if ( row < (ROWS-1) ) {
      grid[row+1][col].infect()
   }
   if ( col > 0) {
      grid[row][col-1].infect()
   }
   if ( col < (COLS-1)) {
      grid[row][col+1].infect()
   }
})

const areGaugesFull =(() => {
   let allFull = true
   gauges.forEach( g =>{
      if (g.isFull() == false) {
         allFull = false
      }
   })
   return allFull
})

const restartHandler = (() => {
   location.reload()
})

const backHandler = (() =>{
   gameStore.fullScreen = false
   gameStore.currentGame = ""
   router.push("/")
})

const wordDisinfectFinished = ( () => {
   //  Increase the letter count gauges and word scoreboard
   let cntIdx = lastWordSize - 3 
   if ( gauges[cntIdx].isFull() == false ) {
      gauges[cntIdx].increaseValue()
   }
   wordCounts[cntIdx]++

   // reset grid and word trackers
   pickNewLetters( lastWordSize )
   letterIndex = 0
   lastWordSize = 0
   Letter.wordFull = false

   // is the game over?
   if ( areGaugesFull()) {
      state.clearVirus()
      clearAllInfections()
   }
})

const clearAllInfections = (()=>{   
   for (let r = (ROWS-1); r >= 0; r--) {
      for (let c = (COLS-1); c  >= 0; c--) {
         if ( grid[r][c].isLost()  || grid[r][c].infected ) {
            grid[r][c].reset( pickNewLetter() )
            startVirusExplode( r, c )
         } 
      }
   }
})

// MAIN GAME LOOP =========================================================
const gameLoop = (() => {
   if (state.isGameOver()) {
      return
   }

   state.update( app.ticker.deltaMS, gameStateChanged)

   if ( state.isSubmitting() || state.isWinning() || state.isLosing() ) {
      // dont advance time or infections while a word is being submitted
      return
   }

   // get prior time and new time. necessary to check if a new second has gone by
   let origTimeSec = Math.round(gameTime / 1000)
   gameTime += app.ticker.deltaMS
   let timeSec = Math.round(gameTime / 1000)

   // Update the timer and display it
   if ( timeSec > origTimeSec) {
      let secs = timeSec
      let mins = Math.floor(timeSec / 60)
      if ( mins > 0) {
         secs = timeSec - mins*60
      }
      let timeStr = `${mins}`.padStart(2,"0")+":"+`${secs}`.padStart(2,"0")
      timerDisplay.text = timeStr
   }

   // Every 30 seconds, increase rate by 10%, and raise infection level
   if ( timeSec>0 && timeSec != lastIncreasedTimeSec && timeSec % 30 == 0) { 
      lastIncreasedTimeSec = timeSec
      Letter.increseInfectionRate()
      if (infectionLevel < MAX_INFECTIONS) {
         infectionLevel++
      }
      // console.log("NEW RATE: "+Letter.infectRatePerSec+"  LEVEL "+infectionLevel)
   }

   // is it time to check for infectedd tile counts (very second)?
   checkCountdown -= app.ticker.deltaMS 
   if (checkCountdown <= 0 ) {
      checkInfectedCount()
      // if (pendingInfections > 0) {
      //    console.log("Checked infections. NEW pending: "+pendingInfections)
      // }
   }

   // if more infections are pending add them once per second
   if ( pendingInfections > 0 ) {
      addCountdown -= app.ticker.deltaMS 
      if (addCountdown <=0)  {
         addCountdown = 1000
         addInfectedTile()
         pendingInfections--
      }
   }

   // Tick all letters to gro infection. Pass along a callback for lost letter
   for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
         grid[r][c].update(app.ticker.deltaMS, letterLost)
      }
   }
})

const gameStateChanged = (( oldState, newState, ) => {
   // console.log("NEW STATE FROM "+oldState+" TO "+newState)
   if (newState == GameState.SUBMIT) {
      doSubmission()
   } else if (newState == GameState.PLAY) {
      setWordColor(0xcccccc)
      if ( oldState == GameState.FAIL) {
         clearWord()
      } if ( oldState == GameState.SUCCESS) {
         wordDisinfectFinished()
      }
   } else if ( newState == GameState.SUCCESS) {
      letterIndex--
      disinfectLetter( )
   } else if ( newState == GameState.GAME_OVER )  {
      if ( oldState == GameState.CLEAR_ALL ) {
         winOverlay.updateStats(Math.round(gameTime / 1000), wordCounts)
         scene.addChild(winOverlay)
      } else if (oldState == GameState.PLAYER_LOST ) {
         gameOverOverlay.updateStats(Math.round(gameTime / 1000), wordCounts)
         scene.addChild(gameOverOverlay)
      }
   }
})

onBeforeUnmount(() => {
   app.ticker.stop()
   if (initGameOverlay) {
      initGameOverlay.destroy()
   }
   if (gameOverOverlay) {
      initGameOverlay.destroy()
   }
   if (winOverlay) {
      winOverlay.destroy()
   }
   scene.destroy({
      children: true,
      texture: true,
      baseTexture: true
   })
   app.stage.removeChildren()
   gameElement.removeChild(app.view)
})
</script>

<style scoped>
#game {
   margin-top: 0;
}
</style>

