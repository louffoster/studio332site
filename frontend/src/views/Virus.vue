<template>
   <div id="game">
   </div>
</template>

<script setup>
import GameState from "@/games/virus/gamestate"
import Letter from "@/games/virus/letter"
import EnterKey from "@/games/virus/enterkey"
import ShuffleKey from "@/games/virus/shufflekey"
import StartOverlay from "@/games/virus/startoverlay"
import EndOverlay from "@/games/virus/endoverlay"
import WinOverlay from "@/games/virus/winoverlay"
import Gauge from "@/games/virus/gauge"
import Pool from "@/games/virus/pool"
import * as PIXI from "pixi.js"
import { onMounted, onBeforeUnmount } from "vue"
import axios from 'axios'
import * as particles from '@pixi/particle-emitter'

import boom from '@/assets/explode.json'

const API_SERVICE = import.meta.env.VITE_S332_SERVICE

const ROWS = 6
const COLS = 5
const GAME_WIDTH = 300
const GAME_HEIGHT = 600
const MAX_INFECTIONS = 8

var app = null
var scene = null
var gfx = null
var boom2 = null

var grid = null
var pool = new Pool()
var initGameOverlay = null
var gameOverOverlay = null
var winOverlay = null
var state = new GameState()
var checkCountdown = 0
var addCountdown = 1000
var lastIncreasedTimeSec = 0
var infectionLevel = 3     // minmum number of infected tiles
var pendingInfections = 0  // numner of infections to add to bring up to current level
var gameTime = 0.0
var timerDisplay = null


var letterIndex = 0
var word = []
var lastWordSize = 0
var wordCounts = []

var gauges = []
var gameplayToken = ""

onMounted(async () => {
   // update partticle effect generated by UI to current version
   boom2 = particles.upgradeConfig(boom, ['spark.png'])

   PIXI.settings.RESOLUTION = window.devicePixelRatio || 1
   app = new PIXI.Application({
      autoDensity: true, // Handles high DPI screens
      backgroundColor: 0x44444a,
      width: GAME_WIDTH,
      height: GAME_HEIGHT,
   })

   // The application will create a canvas element for you that you
   // can then insert into the DOM, then add the base scene container 
   // in this setup, all content added to the scene is auto scaled
   let gameEle = document.getElementById("game")
   gameEle.appendChild(app.view)
   scene = new PIXI.Container()
   app.stage.addChild(scene)

   layoutGameScreen()

   initGameOverlay = new StartOverlay(API_SERVICE) 
   gameOverOverlay = new EndOverlay(restartHandler) 
   winOverlay = new WinOverlay(restartHandler) 
   scene.addChild(initGameOverlay)
   initGameOverlay.startGameInit( startGame )
})

const layoutGameScreen =(() => {
   gfx = new PIXI.Graphics() 
   scene.addChild(gfx)

   // gfx.beginFill(0x664444)
   // gfx.drawRect(0, 289, GAME_WIDTH, 64)
   // gfx.endFill()
   // gfx.lineStyle(1, 0xcc0000, 1)
   // gfx.moveTo(0, 289)
   // gfx.lineTo(GAME_WIDTH, 289)

   let y = 40
   let x = 40   
   grid = Array(ROWS).fill().map(() => Array(COLS))
   for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
         let l = new Letter("", x,y, r,c)
         l.setClickCallback(letterClicked)
         scene.addChild(l)
         grid[r][c] = l
         x += 55
      }
      y += 55
      x = 40
   } 

   let style = new PIXI.TextStyle({
      fill: "#cccccc",
      fontFamily: "\"Courier New\", Courier, monospace",
      fontSize: 24,
   })

   gfx.lineStyle(1, 0x888899, 1)
   gfx.moveTo(0, 352)
   gfx.lineTo(GAME_WIDTH, 352)
   gfx.moveTo(0, 413)
   gfx.lineTo(GAME_WIDTH, 413)

   // setup blank word... to be filled with clicked letters from grid
   x = 10
   for ( let i=0; i<6; i++) {
      // draw the underline for the lettercl
      gfx.moveTo(x, 395)
      gfx.lineTo(x+20, 395)  

      let wordLetter = new PIXI.Text("", style)
      wordLetter.x = x+2
      wordLetter.y = 365
      scene.addChild(wordLetter)
      word.push( {letter: wordLetter, fromRow: -1, fromCol: -1})

      x+=25
   }

   let enterKey = new EnterKey(170,365, enterWord)
   scene.addChild(enterKey)
   let shuffleKey = new ShuffleKey(170+70 ,365, shuffleGrid)
   scene.addChild(shuffleKey)

   // word count gauges
   gauges = []
   let maxValues = [10,6,4,3] 
   let gaugeY = 430
   for (let i=0; i<4; i++) {
      let g = new Gauge(10,gaugeY,`${i+3}`, maxValues[i])
      gauges.push( g )
      scene.addChild( g )
      gaugeY+=28
   }

   // timer 
   gfx.moveTo(0, 550)
   gfx.lineTo(GAME_WIDTH, 550)
   timerDisplay = new PIXI.Text("System Time: 00:00", {
      fill: "#44cc44",
      fontFamily: "\"Courier New\", Courier, monospace",
      fontSize: 18,
   })
   timerDisplay.anchor.set(0.5,0)
   timerDisplay.x = GAME_WIDTH/2
   timerDisplay.y = 565
   scene.addChild(timerDisplay)
})

const startGame = (( jwt ) => {
   gameplayToken = jwt
   console.log("TOKEN: " + gameplayToken)
   scene.removeChild(initGameOverlay)

   pool.refill()
   wordCounts = [0,0,0,0] // one for each letter count; 3,4,5,6

   for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
         grid[r][c].reset( pool.pop() )
      }
   } 

   state.initialized()
   app.start()
   app.ticker.add( gameLoop )
})

const checkInfectedCount = (() => {
   checkCountdown = 1000.0
   let cnt = 0
   for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
         if ( grid[r][c].isInfected() ) {
            cnt++
         }
      }
   }

   // If there is nothing, always start with 3 in alternating columns in first row
   if (cnt == 0) {
      grid[0][0].infect()
      grid[0][2].infect()
      grid[0][4].infect()
      cnt = 3
   }

   // keep the number of infected tiles at a minum of the current level
   if ( cnt < infectionLevel) {
      pendingInfections = infectionLevel - cnt
      addCountdown = 1000
   } else {
      pendingInfections = 0
      addCountdown = 0
   }
})

const addInfectedTile = (() => {
   let added = false
   for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
         if (grid[r][c].infected == false) {
            grid[r][c].infect()
            added  = true
            break 
         }
      }
      if (added ) break
   }
})

const shuffleGrid =(() => {
   if (state.isGameOver()) return 
   
   clearWord()
   let newLetters = pickNewLetters(ROWS*COLS) 
   for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
         grid[r][c].replace( newLetters.pop() )  
      }
   }
})

const enterWord = (() => {
   if (state.isGameOver()) return
   state.requestSubmit()
   setWordColor(0xaaddff)  
})

const doSubmission = ( async () => {
   // 3 letters or more required!
   // TODO flash error
   if ( letterIndex < 3) {
      addInfectedTile()
      failedWord()
      return
   }

   let testWord = ""
   word.forEach( l => testWord += l.letter.text)
   let url = `${API_SERVICE}/virus/check?w=${testWord}`
   await axios.post(url).then( () => {
      wordAccepted( )
   }).catch( _e => {
      failedWord()
      addInfectedTile()
   })
})

const failedWord = (() => {
   setWordColor(0xff5555)
   state.submitFailed()
})

const setWordColor = (( c ) => {
   word.forEach( wl => {
      wl.letter.style.fill = c
   }) 
})

const wordAccepted = (() => {
   // letter index is the index of the next letter to add, so it is the word length
   lastWordSize = letterIndex 
   state.submitSuccess( lastWordSize )
})

const disinfectLetter = (() =>{
   // clear the letter from the word and deselect it from the grid
   let selR = word[letterIndex].fromRow
   let selC = word[letterIndex].fromCol 
   let isSelectedInfected = grid[selR][selC].infected

   // reset grid letter and clear word letter
   grid[selR][selC].reset( pickNewLetter() )   
   word[letterIndex].letter.text = ""
   word[letterIndex].fromCol = -1
   word[letterIndex].fromRow = -1  

   // If this letter was infected, nothing left to do
   if ( isSelectedInfected ) {
      startExplode( selR, selC)
      return
   } 

   // no infected tiles cleared for first letter
   if (letterIndex == 0) {
      return
   }

   // go from bottom right to top left and clear one infected or lost tile
   let done = false
   for (let r = (ROWS-1); r >= 0; r--) {
      for (let c = (COLS-1); c  >= 0; c--) {
         // restore infected or lost letter from the grid
         if ( grid[r][c].isLost()  || grid[r][c].infected ) {
            let type = "infected"
            if (grid[r][c].isLost()) {
               type = "LOST"
            }
            console.log(`clear ${type} tile at ${r}, ${c}`)
            grid[r][c].reset( pickNewLetter() )
            done = true
            startExplode( r, c )
            break
         }
      }
      if (done) {
         break
      }
   }
})

const clearWord = (() => {
   word.forEach( wl  => {
      if (wl.letter.text != "") {
         grid[wl.fromRow][wl.fromCol].deselect()
         wl.letter.text = ""
         wl.fromCol = -1
         wl.fromRow = -1   
      }
   })
   letterIndex = 0
   lastWordSize = 0
   Letter.wordFull = false
})

const pickNewLetter = (() => {
   let l = pickNewLetters(1)
   return l[0]
})
const pickNewLetters = (( cnt ) => {
   let out = [] 
   for (let i=0; i<cnt; i++ ) {
      if ( pool.hasTilesLeft() == false) {
         pool.refill()
      }
      out.push( pool.pop() )
   }
   return out
})

const letterClicked = (( selected, row, col, letter) => {
   if (state.isGameOver()) return 

   Letter.wordFull = false
   if (selected) {
      word[letterIndex].letter.text = letter
      word[letterIndex].fromCol = col
      word[letterIndex].fromRow = row 
      letterIndex++ 
      if (letterIndex == 6) {
         Letter.wordFull = true
      }
   } else {
      clearWord()
   }
})

const startExplode = ((row, col) => {
   var emitter = new particles.Emitter(scene, boom2 )

   // start of grid is 40,40 each letter is 55x55
   let x = 40 + (col*55)
   let y = 40 + (row*55)
   emitter.updateOwnerPos(0,0)
   emitter.updateSpawnPos(x,y)
   emitter.playOnceAndDestroy()
})

const letterLost = (( row, col ) => {
   if ( state.isGameOver()) return

   let biggestWordLeft = 0 
   gauges.forEach( g =>{
      if (g.isFull() == false) {
         biggestWordLeft = Math.max(g.maxValue)   
      }
   })

   let remainingLetters = 0
   for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
         if ( grid[r][c].isLost() == false) {
            remainingLetters++
         }
      }
   }
   
   if ( remainingLetters < biggestWordLeft ) {
      state.gameOver()
      gameOverOverlay.updateStats(Math.round(gameTime / 1000), wordCounts)
      scene.addChild(gameOverOverlay)
      return
   }

   // // if any in the last row are lost, game over
   // if (row == ROWS-1) {
   //    for (let r = 0; r < ROWS; r++) {
   //       for (let c = 0; c < COLS; c++) {
   //          grid[r][c].replace( "" )
   //       }
   //    } 
   //    state.gameOver()
   //    gameOverOverlay.updateStats(Math.round(gameTime / 1000), wordCounts)
   //    scene.addChild(gameOverOverlay)
   //    return
   // }
   let isInWord = false 
   word.forEach( wl => {
      if (wl.fromRow == row && wl.fromCol == col) {
         isInWord = true
      }
   })
   if ( isInWord ) {
      clearWord()
   }

   if ( row > 0) {
      grid[row-1][col].infect()
   }
   if ( row < (ROWS-1) ) {
      grid[row+1][col].infect()
   }
   if ( col > 0) {
      grid[row][col-1].infect()
   }
   if ( col < (COLS-1)) {
      grid[row][col+1].infect()
   }
})

const areGaugesFull =(() => {
   let allFull = true
   gauges.forEach( g =>{
      if (g.isFull() == false) {
         allFull = false
      }
   })
   return allFull
})

const restartHandler = (() => {
   Letter.wordFull = false 
   Letter.infectRatePerSec = 5.0
   letterIndex = 0
   lastWordSize = 0
   checkCountdown = 1000
   addCountdown = 1000
   lastIncreasedTimeSec = 0
   gameTime = 0.0
   for ( let i=0; i<6; i++) {
     word[i].letter.text = ""
     word[i].fromRow = -1
     word[i].fromCol = -1
   }
   wordCounts = []
   for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
         grid[r][c].reset( "" )
         grid[r][c].update(0, letterLost)
      }
   } 

   gauges.forEach( g => g.reset() )
   
   scene.removeChild(winOverlay)
   scene.removeChild(gameOverOverlay)
   scene.addChild(initGameOverlay)
   initGameOverlay.startGameInit( startGame )
})

const wordDisinfectFinished = ( () => {
   //  Increase the letter count gauges and word scoreboard
   let cntIdx = lastWordSize - 3 
   if ( gauges[cntIdx].isFull() == false ) {
      gauges[cntIdx].increaseValue()
   }
   wordCounts[cntIdx]++

   // reset grid and word trackers
   pickNewLetters( lastWordSize )
   letterIndex = 0
   lastWordSize = 0
   Letter.wordFull = false

   // is the game over?
   if ( areGaugesFull()) {
      state.gameOver()
      winOverlay.updateStats(Math.round(gameTime / 1000), wordCounts)
      scene.addChild(winOverlay)
   }
})

// MAIN GAME LOOP =========================================================
const gameLoop = (() => {
   if (state.isGameOver()) {
      return
   }

   // get prior time and new time. necessary to check if a new second has gone by
   let origTimeSec = Math.round(gameTime / 1000)
   gameTime += app.ticker.deltaMS
   let timeSec = Math.round(gameTime / 1000)

   // Update the timer and display it
   if ( timeSec > origTimeSec) {
      let secs = timeSec
      let mins = Math.floor(timeSec / 60)
      if ( mins > 0) {
         secs = timeSec - mins*60
      }
      let timeStr = "Uptime: "+`${mins}`.padStart(2,"0")+":"+`${secs}`.padStart(2,"0")
      timerDisplay.text = timeStr
   }

   state.update( app.ticker.deltaMS, gameStateChanged)
   if ( state.isSubmitting() ) {
      // dont advance infections while a word is being submitted
      return
   }

   // Every 30 seconds, increase rate by 10%, and raise infection level
   if ( timeSec>0 && timeSec != lastIncreasedTimeSec && timeSec % 30 == 0) { 
      lastIncreasedTimeSec = timeSec
      Letter.increseInfectionRate()
      if (infectionLevel < MAX_INFECTIONS) {
         infectionLevel++
      }
      console.log("NEW RATE: "+Letter.infectRatePerSec+"  LEVEL "+infectionLevel)
   }

   // is it time to check for infectedd tile counts (very second)?
   checkCountdown -= app.ticker.deltaMS 
   if (checkCountdown <= 0 ) {
      checkInfectedCount()
      if (pendingInfections > 0) {
         console.log("Checked infections. NEW pending: "+pendingInfections)
      }
   }

   // if more infections are pending add them once per second
   if ( pendingInfections > 0 ) {
      addCountdown -= app.ticker.deltaMS 
      if (addCountdown <=0)  {
         addCountdown = 1000
         addInfectedTile()
         pendingInfections--
         console.log("ADDED pending infection. Pending: "+pendingInfections)
      }
   }

   // Tick all letters to gro infection. Pass along a callback for lost letter
   for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
         grid[r][c].update(app.ticker.deltaMS, letterLost)
      }
   }
})

const gameStateChanged = (( oldState, newState, ) => {
   console.log("NEW STATE FROM "+oldState+" TO "+newState)
   if (newState == GameState.SUBMIT) {
      doSubmission()
   } else if (newState == GameState.PLAY) {
      setWordColor(0xcccccc)
      if ( oldState == GameState.FAIL) {
         clearWord()
      } if ( oldState == GameState.SUCCESS) {
         wordDisinfectFinished()
      }
   } else if ( newState == GameState.SUCCESS) {
      letterIndex--
      disinfectLetter( )
   }
})

onBeforeUnmount(() => {
   app.ticker.stop()
   if (initGameOverlay) {
      initGameOverlay.destroy()
   }
   if (gameOverOverlay) {
      initGameOverlay.destroy()
   }
   if (winOverlay) {
      winOverlay.destroy()
   }
   scene.destroy({
      children: true,
      texture: true,
      baseTexture: true
   })
   app.stage.removeChildren()
   let gameEle = document.getElementById("game")
   gameEle.removeChild(app.view)
})
</script>

<style scoped>
#game {
   margin-top: 15px;
}
</style>

